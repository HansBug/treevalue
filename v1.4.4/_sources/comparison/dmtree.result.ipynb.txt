{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "# Comparison Between TreeValue and DM-Tree"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In this section, we will compare the feature and performance of the [dm-tree](https://github.com/deepmind/tree) library, which is developed by deepmind."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Before starting the comparison, let us define some thing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:53.351017Z",
     "iopub.status.busy": "2023-02-25T07:44:53.350732Z",
     "iopub.status.idle": "2023-02-25T07:44:53.360589Z",
     "shell.execute_reply": "2023-02-25T07:44:53.359627Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "origin = {'a': 1, 'b': 2, 'c': {'x': 3, 'y': 4}}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "## Mapping Operation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Mapping operation is quite common in the processing of trees. A mapping function should be provided to create a new tree based on the mapped tree."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "### TreeValue's mapping"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In TreeValue, mapping is provided to simply create a new tree."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:53.364437Z",
     "iopub.status.busy": "2023-02-25T07:44:53.364155Z",
     "iopub.status.idle": "2023-02-25T07:44:53.427292Z",
     "shell.execute_reply": "2023-02-25T07:44:53.426105Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<FastTreeValue 0x7f3eac3e1d30>\n",
       "├── 'a' --> 1\n",
       "├── 'b' --> 2\n",
       "└── 'c' --> <FastTreeValue 0x7f3eac3e1d00>\n",
       "    ├── 'x' --> 3\n",
       "    └── 'y' --> 4"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from treevalue import FastTreeValue, mapping\n",
    "\n",
    "tv = FastTreeValue(origin)\n",
    "tv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:53.479549Z",
     "iopub.status.busy": "2023-02-25T07:44:53.478773Z",
     "iopub.status.idle": "2023-02-25T07:44:53.485567Z",
     "shell.execute_reply": "2023-02-25T07:44:53.484662Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<FastTreeValue 0x7f3eac09b700>\n",
       "├── 'a' --> 2\n",
       "├── 'b' --> 4\n",
       "└── 'c' --> <FastTreeValue 0x7f3eac09b4c0>\n",
       "    ├── 'x' --> 6\n",
       "    └── 'y' --> 8"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mapping(tv, lambda x: x * 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance test."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:53.489479Z",
     "iopub.status.busy": "2023-02-25T07:44:53.489034Z",
     "iopub.status.idle": "2023-02-25T07:44:55.698978Z",
     "shell.execute_reply": "2023-02-25T07:44:55.697939Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.71 µs ± 83.4 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit mapping(tv, lambda x: x * 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In order to support the cased that the mapped value is related to both path and value of each node, we can use the 'path mapping mode' by simply use the second parameter of the mapping function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:55.702766Z",
     "iopub.status.busy": "2023-02-25T07:44:55.702334Z",
     "iopub.status.idle": "2023-02-25T07:44:55.711343Z",
     "shell.execute_reply": "2023-02-25T07:44:55.710434Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<FastTreeValue 0x7f3eac0a8520>\n",
       "├── 'a' --> ('path', ('a',), 'value', 1)\n",
       "├── 'b' --> ('path', ('b',), 'value', 2)\n",
       "└── 'c' --> <FastTreeValue 0x7f3eac0a82b0>\n",
       "    ├── 'x' --> ('path', ('c', 'x'), 'value', 3)\n",
       "    └── 'y' --> ('path', ('c', 'y'), 'value', 4)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mapping(tv, lambda x, p: ('path', p, 'value', x))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "And here is the performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:55.714782Z",
     "iopub.status.busy": "2023-02-25T07:44:55.714352Z",
     "iopub.status.idle": "2023-02-25T07:44:58.036523Z",
     "shell.execute_reply": "2023-02-25T07:44:58.035612Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.86 µs ± 69 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit mapping(tv, lambda x, p: ('path', p, 'value', x))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "### DM-Tree's mapping"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In DM-Tree, mapping operation is supported by [map_structure](https://tree.readthedocs.io/en/latest/api.html#tree.map_structure) function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:58.040611Z",
     "iopub.status.busy": "2023-02-25T07:44:58.039888Z",
     "iopub.status.idle": "2023-02-25T07:44:58.046968Z",
     "shell.execute_reply": "2023-02-25T07:44:58.046019Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "from tree import map_structure"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:58.050397Z",
     "iopub.status.busy": "2023-02-25T07:44:58.050091Z",
     "iopub.status.idle": "2023-02-25T07:44:58.060809Z",
     "shell.execute_reply": "2023-02-25T07:44:58.059864Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': 2, 'b': 4, 'c': {'x': 6, 'y': 8}}"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "map_structure(lambda x: x * 2, origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "This is the performance of `map_structure`, obviously much slower than `mapping` in TreeValue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:58.064270Z",
     "iopub.status.busy": "2023-02-25T07:44:58.063983Z",
     "iopub.status.idle": "2023-02-25T07:44:59.695640Z",
     "shell.execute_reply": "2023-02-25T07:44:59.694643Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "20 µs ± 649 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit map_structure(lambda x: x * 2, origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "To supported the second situation in the last section, [map_structure_with_path](https://tree.readthedocs.io/en/latest/api.html#tree.map_structure_with_path) can be used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:59.699780Z",
     "iopub.status.busy": "2023-02-25T07:44:59.699080Z",
     "iopub.status.idle": "2023-02-25T07:44:59.704465Z",
     "shell.execute_reply": "2023-02-25T07:44:59.703528Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "from tree import map_structure_with_path"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:59.707674Z",
     "iopub.status.busy": "2023-02-25T07:44:59.707369Z",
     "iopub.status.idle": "2023-02-25T07:44:59.715804Z",
     "shell.execute_reply": "2023-02-25T07:44:59.714874Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': ('path', ('a',), 'value', 1),\n",
       " 'b': ('path', ('b',), 'value', 2),\n",
       " 'c': {'x': ('path', ('c', 'x'), 'value', 3),\n",
       "  'y': ('path', ('c', 'y'), 'value', 4)}}"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "map_structure_with_path(lambda path, x: ('path', path, 'value', x), origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:44:59.719141Z",
     "iopub.status.busy": "2023-02-25T07:44:59.718868Z",
     "iopub.status.idle": "2023-02-25T07:45:03.259065Z",
     "shell.execute_reply": "2023-02-25T07:45:03.258145Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "43.5 µs ± 690 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit map_structure_with_path(lambda path, x: ('path', path, 'value', x), origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "## Flatten and Unflatten"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In tree operations, flatten is often used to linearly expand the tree structure for operations such as parallel processing. Based on flatten, unflatten is its inverse operation, which can recover the tree structure from the linear data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "### TreeValue's Performance"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In TreeValue, flatten and unflatten are provided, which usage are simple."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:03.263581Z",
     "iopub.status.busy": "2023-02-25T07:45:03.263100Z",
     "iopub.status.idle": "2023-02-25T07:45:03.269602Z",
     "shell.execute_reply": "2023-02-25T07:45:03.268674Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<FastTreeValue 0x7f3eac0b0df0>\n",
       "├── 'a' --> 1\n",
       "├── 'b' --> 2\n",
       "└── 'c' --> <FastTreeValue 0x7f3eac0b0d60>\n",
       "    ├── 'x' --> 3\n",
       "    └── 'y' --> 4"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from treevalue import FastTreeValue, flatten, unflatten\n",
    "\n",
    "origin_tree = FastTreeValue(origin)\n",
    "origin_tree"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:03.273248Z",
     "iopub.status.busy": "2023-02-25T07:45:03.272685Z",
     "iopub.status.idle": "2023-02-25T07:45:03.278694Z",
     "shell.execute_reply": "2023-02-25T07:45:03.277721Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[(('a',), 1), (('b',), 2), (('c', 'x'), 3), (('c', 'y'), 4)]"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "flatted = flatten(origin_tree)\n",
    "flatted"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance of `flatten`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:03.282855Z",
     "iopub.status.busy": "2023-02-25T07:45:03.282345Z",
     "iopub.status.idle": "2023-02-25T07:45:10.518632Z",
     "shell.execute_reply": "2023-02-25T07:45:10.517595Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "891 ns ± 21.1 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit flatten(origin_tree)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "The tree can be re-created from `flatted` with function `unflatten`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:10.522288Z",
     "iopub.status.busy": "2023-02-25T07:45:10.521990Z",
     "iopub.status.idle": "2023-02-25T07:45:10.529869Z",
     "shell.execute_reply": "2023-02-25T07:45:10.528930Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<TreeValue 0x7f3eac3e1bb0>\n",
       "├── 'a' --> 1\n",
       "├── 'b' --> 2\n",
       "└── 'c' --> <TreeValue 0x7f3eac3e1af0>\n",
       "    ├── 'x' --> 3\n",
       "    └── 'y' --> 4"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "unflatten(flatted)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "And here is the performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:10.533222Z",
     "iopub.status.busy": "2023-02-25T07:45:10.532936Z",
     "iopub.status.idle": "2023-02-25T07:45:18.480115Z",
     "shell.execute_reply": "2023-02-25T07:45:18.478694Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "982 ns ± 15.3 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit unflatten(flatted)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "### DM-Tree's Performance"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "[Flatten](https://tree.readthedocs.io/en/latest/api.html#tree.flatten) is provided in DM-Tree as well, but it differs from that in TreeValue, as the following"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:18.484290Z",
     "iopub.status.busy": "2023-02-25T07:45:18.483548Z",
     "iopub.status.idle": "2023-02-25T07:45:18.492119Z",
     "shell.execute_reply": "2023-02-25T07:45:18.490966Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 3, 4]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from tree import flatten\n",
    "\n",
    "flatten(origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:18.495567Z",
     "iopub.status.busy": "2023-02-25T07:45:18.495281Z",
     "iopub.status.idle": "2023-02-25T07:45:28.885118Z",
     "shell.execute_reply": "2023-02-25T07:45:28.883912Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.28 µs ± 21.2 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit flatten(origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "The structure of the tree is dropped, only the data is extracted from the tree. This means the `flatten` function in DM-Tree is irreversible, we can not recover the original tree with the result above."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "The reversible resolution provided in DM-Tree is [flatten_with_path](https://tree.readthedocs.io/en/latest/api.html#tree.flatten_with_path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:28.889253Z",
     "iopub.status.busy": "2023-02-25T07:45:28.888937Z",
     "iopub.status.idle": "2023-02-25T07:45:28.897579Z",
     "shell.execute_reply": "2023-02-25T07:45:28.896632Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[(('a',), 1), (('b',), 2), (('c', 'x'), 3), (('c', 'y'), 4)]"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from tree import flatten_with_path\n",
    "\n",
    "flatten_with_path(origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance, much slower than `flatten` in TreeValue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:28.901150Z",
     "iopub.status.busy": "2023-02-25T07:45:28.900827Z",
     "iopub.status.idle": "2023-02-25T07:45:30.533009Z",
     "shell.execute_reply": "2023-02-25T07:45:30.532006Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "19.8 µs ± 496 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit flatten_with_path(origin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "To re-create the original tree, we need a tree structure with any objects filled inside. Use the [unflatten_as](https://tree.readthedocs.io/en/latest/api.html#tree.unflatten_as) to archive this goal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:30.536810Z",
     "iopub.status.busy": "2023-02-25T07:45:30.536367Z",
     "iopub.status.idle": "2023-02-25T07:45:30.545048Z",
     "shell.execute_reply": "2023-02-25T07:45:30.544085Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': 1, 'b': 2, 'c': {'x': 3, 'y': 4}}"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from tree import unflatten_as\n",
    "\n",
    "unflatten_as({'a': None, 'b': None, 'c': {'x': None, 'y': None}}, [1, 2, 3, 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:30.548667Z",
     "iopub.status.busy": "2023-02-25T07:45:30.548394Z",
     "iopub.status.idle": "2023-02-25T07:45:43.476495Z",
     "shell.execute_reply": "2023-02-25T07:45:43.475495Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "15.9 µs ± 216 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit unflatten_as({'a': None, 'b': None, 'c': {'x': None, 'y': None}}, [1, 2, 3, 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "### Positional Replacement"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "It is obvious that the `unflatten_as` in DM-Tree is quite different from `unflatten` in TreeValue, for the former one is `replacing` and the latter one is `constructing`. This means the `unflatten_as` in DM-Tree may supported some more features, such as creating a new tree with another tree's structure and the given values. So we need an experiment on this, called 'positional replacement'."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "First, in TreeValue, we can build a function named `replace` to realize this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:43.480554Z",
     "iopub.status.busy": "2023-02-25T07:45:43.480268Z",
     "iopub.status.idle": "2023-02-25T07:45:43.488086Z",
     "shell.execute_reply": "2023-02-25T07:45:43.485857Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [],
   "source": [
    "from treevalue import flatten, unflatten\n",
    "\n",
    "def replace(t, v):\n",
    "    pairs = flatten(t)\n",
    "    return unflatten([(path, vi) for (path, _), vi in zip(pairs, v)])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Create a new tree based on `origin_tree`'s structure and new values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:43.491564Z",
     "iopub.status.busy": "2023-02-25T07:45:43.491023Z",
     "iopub.status.idle": "2023-02-25T07:45:43.499321Z",
     "shell.execute_reply": "2023-02-25T07:45:43.498374Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<TreeValue 0x7f3eac0d6430>\n",
       "├── 'a' --> 3\n",
       "├── 'b' --> 5\n",
       "└── 'c' --> <TreeValue 0x7f3eac0d6220>\n",
       "    ├── 'x' --> 7\n",
       "    └── 'y' --> 9"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "replace(origin_tree, [3, 5, 7, 9])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:43.503522Z",
     "iopub.status.busy": "2023-02-25T07:45:43.503220Z",
     "iopub.status.idle": "2023-02-25T07:45:45.842873Z",
     "shell.execute_reply": "2023-02-25T07:45:45.841799Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.88 µs ± 30.8 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit replace(origin_tree, [3, 5, 7, 9])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "In DM-Tree, `unflatten_as` can be directly used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:45.846901Z",
     "iopub.status.busy": "2023-02-25T07:45:45.846367Z",
     "iopub.status.idle": "2023-02-25T07:45:45.852795Z",
     "shell.execute_reply": "2023-02-25T07:45:45.851885Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': 3, 'b': 5, 'c': {'x': 7, 'y': 9}}"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from tree import unflatten_as\n",
    "\n",
    "unflatten_as(origin, [3, 5, 7, 9])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "Here is the performance, even much slower than the `replace` function for integration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2023-02-25T07:45:45.856247Z",
     "iopub.status.busy": "2023-02-25T07:45:45.855936Z",
     "iopub.status.idle": "2023-02-25T07:45:58.693344Z",
     "shell.execute_reply": "2023-02-25T07:45:58.692342Z"
    },
    "pycharm": {
     "name": "#%%\n"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "15.9 µs ± 175 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit unflatten_as(origin, [3, 5, 7, 9])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "## Conclusion"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "The mapping operation is supported by both library, and `mapping` in TreeValue's performance is significantly higher than the `map_structure` and `map_structure_with_path` in DM-Tree."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": false,
    "pycharm": {
     "name": "#%% md\n"
    }
   },
   "source": [
    "The `flatten` and `unflatten` in TreeValue is reversible, but in DM-Tree not. DM-Tree's performance on flatten and unflatten operation is lower than that in TreeValue in all aspects."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.16"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
